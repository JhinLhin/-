## Single server setup

单服务器架构 = 用最低成本把 MVP 跑起来：同一台机器同时提供 `www` 的 HTML 和 `api` 的 JSON；用户先 DNS 把域名翻译成 IP，再用 HTTP 打到服务器拿响应。

✅ 固定流程句（万能）

> 用户输入：`api.mysite.com`
>
> DNS 返回：`15.125.23.214`
>
> 请求：`GET http://15.125.23.214/users/12`（实际会带 Host=api.mysite.com）
>
> 响应：`200 OK` + JSON（用户对象）

✅ 固定解释句（为什么要 DNS）

> **域名给人看，IP 给机器用；DNS 就是把人类可读名翻译成机器可路由地址。**

✅ 固定对比句（HTML vs JSON）

> **HTML 给浏览器直接渲染；JSON 给 App/前端自己决定怎么展示，便于多端复用 API。**

✅ 固定权衡句（单服务器优缺点）

> **优点：简单、快、便宜；缺点：SPOF一挂全挂 + 扩容主要靠 vertical scaling。**

## Database

**1) 为什么把 Database 单独拿出来（Web tier / Data tier）**

- ⭐ **核心结论**：**Web（计算/请求）** 和 **DB（存储/事务/查询）** 分层，便于 **独立扩缩容 + 性能隔离 + 安全隔离**。
- ⭐ **面试标准答法（3点）**
  1. **扩展性**：Web 压力大 → 加 Web Server（水平扩展）；DB 压力大 → 升级/读写分离/分片
  2. **性能**：DB I/O 密集；Web CPU/网络密集 → 拆开避免互抢资源
  3. **安全**：DB 放内网，仅允许 Web tier 访问，减少暴露面
- ⚠️ **易错**：分离 ≠ 只为了“更清晰架构”，面试要说 **可扩展/可用/安全** 这些硬指标。
- ❌ **可不记**：网店类比的长故事，只保留“分层+独立扩缩容”。

------

**2) 请求链路（按图口述）**

- ⭐ **背诵版步骤（5步）**
  1. Client 访问域名（`www` 或 `api`）
  2. DNS 解析到 IP
  3. Client → Web Server 发 HTTP 请求
  4. Web Server → DB 执行 **read/write/update**
  5. DB 返回 → Web Server 组装 → 返回 **HTML/JSON**
- ⚠️ **易错**：Client **不直接连 DB**（常见安全/架构实践）。

------

**3) SQL vs NoSQL（怎么考、怎么答）**

**3.1 一句话对比（必背）**

- ⭐ **SQL / RDBMS**：**结构化表** + **SQL 查询强（Join）** + **事务/一致性（ACID）强**
- ⭐ **NoSQL**：**模型灵活** + **易水平扩展/高吞吐** + 通常 **不擅长 Join（靠冗余/应用层聚合）**

**3.2 NoSQL 四大类（面试最爱听的分类）**

- ⭐ **Key-Value**：`key -> value`，简单读写、低延迟
- ⭐ **Document**：JSON 文档，字段可变
- ⭐ **Column-family**：列式/宽列，适合海量写入/分析场景（常考“适合大数据”）
- ⭐ **Graph**：节点+边，关系查询（社交/推荐）
- ⚠️ **易混**：Column-family（NoSQL）≠ 关系型的“按列存”；说清是 NoSQL 的宽列模型即可。

**3.3 选型回答模板（直接套）**

- ⭐ **如果需要：强一致 + 事务 + Join/复杂查询** → 选 **SQL**（订单/支付/账户）
- ⭐ **如果需要：高吞吐 + 易扩展 + 模式灵活** → 选 **NoSQL**（日志/事件/内容/大规模简单读写）
- ⚠️ **易错**：别说“SQL 不能扩展/NoSQL 没一致性”——正确说法：
  - SQL **水平扩展更复杂**
  - NoSQL **一致性/查询能力通常需要权衡**

------

**4) Trade-offs（至少说 3 个，面试得分点）**

- ⭐ **一致性/事务 vs 扩展/吞吐**：SQL 强一致/事务强；NoSQL 更易水平扩展/吞吐高（但一致性/事务可能要权衡）
- ⭐ **Join/复杂查询 vs 数据冗余**：SQL Join 强；NoSQL 常 **冗余数据** 或应用层组合换性能
- ⭐ **Schema 固定 vs Schema 灵活**：SQL 改字段要迁移；NoSQL 字段可变但数据治理更难
- ⭐（加分）**低延迟简单读写 vs 功能丰富查询报表**：KV/缓存型更低延迟；SQL 更省心做复杂查询/报表
- ⚠️ **易错**：Trade-off 不要空讲，最好加一句“因此我会选…因为…（结合场景）”。

------

**5) 30 秒面试口述版（可直接背）**

- ⭐ “数据库单独拆出来形成 Web tier 和 Data tier，核心是 **独立扩缩容、性能隔离、安全隔离**。请求链路是：客户端用域名访问→DNS 解析→到 Web Server→Web 对 DB 做读写更新→DB 返回→Web 返回 HTML/JSON。选型上，**SQL** 强事务/强一致/Join 与复杂查询，适合订单支付；**NoSQL** 更灵活、易扩展高吞吐，常见 Key-Value/Document/Column/Graph，但通常不擅长 Join，需要冗余或应用层聚合。常见权衡是一致性 vs 扩展、Join vs 冗余、固定 schema vs 灵活 schema。”

## Vertical Scaling and Horizontal Scaling and Load Balancer

**Vertical scaling vs Horizontal scaling（备考压缩版）**

**1) 一句话结论（必背）**

- ⭐ **Vertical / Scale Up**：给**一台**机器加 CPU/RAM/磁盘 → **简单但有天花板 + 单点风险**
- ⭐ **Horizontal / Scale Out**：加**多台**机器进资源池 → **更易扩展 + 更高可用，但系统更复杂（通常要 LB）**
- ⭐ 金句：**Scale up 适合早期；scale out 是大规模主路径。**

------

**2) 怎么考（常见问法）**

- ⭐ “vertical vs horizontal 区别？优缺点？”
- ⭐ “为什么需要 load balancer？解决什么问题？”
- ⭐ “public IP vs private IP 区别？为什么后端用私网？”
- ⚠️ “横向扩容之后会遇到什么新问题？”（会话/状态、健康检查、部署/监控等）

------

**3) 怎么答（评分点清单：按顺序说）**

**3.1 Vertical scaling（scale up）**

- ⭐ **优点**：实现简单、改动小、迁移成本低
- ⭐ **硬缺点（3个背诵点）**
  1. **上限**：硬件有天花板（无法无限加）
  2. **单点故障**：机器挂了服务全挂（无冗余/无 failover）
  3. **升级风险**：升级常需停机/重启（工程风险）

**3.2 Horizontal scaling（scale out）**

- ⭐ **优点（2个背诵点）**
  1. **扩展性强**：可通过加机器线性扩容
  2. **可用性更高**：坏一台还有其他顶上（冗余+故障切换）
- ⚠️ **缺点（要点到复杂度）**：需要配套能力
  - ⭐ LB 分流 + 健康检查
  - ⚠️ **状态/会话问题**（最常考坑）
  - 部署编排、监控告警、容量规划

------

**4) Load Balancer（LB）必背职责（面试高分点）**

- ⭐ **入口统一**：DNS 指向 LB（对外暴露公网入口）
- ⭐ **流量分发**：把请求分配到多台后端 Server
- ⭐ **健康检查**：剔除不健康实例，避免打到坏机器
- ⭐ **故障切换**：某台挂了，流量自动转到健康机器（failover）
- ⚠️ **易错**：只说“平均分配流量”不够，**健康检查/故障切换**是加分关键点。

------

**5) 图口述链路（背诵版）**

- ⭐ 1) Client 访问域名
- ⭐ 2) DNS 解析到 **LB 的公网 IP**
- ⭐ 3) Client → LB
- ⭐ 4) LB → 后端多台 Web Server（通常是 **私网 IP**）
- ⭐ 5) Web Server 处理请求并返回

------

**6) Public IP vs Private IP（必背）**

- ⭐ **Public IP**：互联网可达，对外入口（常用于 LB）
- ⭐ **Private IP**：仅内网可达（后端服务器常用），**减少暴露面更安全**
- ⚠️ 口述加分句：**用户只能到 LB，不能直连后端私网实例。**

------

**7) 横向扩容最常考“新坑”（必背）**

- ⭐ **Stateful 会话问题**：登录态在单机内存会导致“掉登录”
  - ⭐ 解决1：**无状态化**（session/token 放 Redis/DB/集中存储）
  - ⚠️ 解决2：**Sticky session**（简单但不利于弹性/故障切换）

------

**8) 30 秒面试口述版（可直接背）**

- ⭐ “Vertical scaling 是给单机加资源，简单但有上限、单点故障且升级常需停机。Horizontal scaling 是加多台机器进池子，扩展性和可用性更好，但需要负载均衡、健康检查，并处理会话状态等复杂度。LB 作为统一入口（公网 IP），把流量分发到私网后端，并通过健康检查实现故障切换。公网 IP 面向互联网，私网 IP 只在内部网络可达，更安全。”

## Database Replication

**1) 一句话结论（必背）**

- ⭐ **Replication = 数据多副本**：常见是 **1 Master（写）+ N Replica/Slave（读）**
- ⭐ **核心用途**：**读扩展（read scaling）+ 数据冗余（reliability）+ 更高可用（availability）**

------

**2) 怎么考（常见问法）**

- ⭐ “什么是 DB replication？主从各做什么？”
- ⭐ “为什么要 replication？带来哪些收益？”
- ⭐ “读写怎么路由？端到端流程？”
- ⚠️ “replication 的缺点/坑是什么？”（lag、一致性、failover）
- ⚠️ “主从复制能不能解决写扩展？”（常考反问）

------

**3) 怎么答（评分点清单：按顺序说）**

**3.1 架构与角色（必拿分）**

- ⭐ **Master DB**：处理 **写/改/删**（INSERT/UPDATE/DELETE）
- ⭐ **Slave/Replica DB**：从 Master **同步数据**，主要处理 **读**（SELECT）
- ⭐ **典型前提**：业务 **读多写少** → 适合 **1 主多从**

**3.2 端到端请求流程（背诵版 4 步）**

1. ⭐ Client → LB → Web Server
2. ⭐ Web Server 根据操作类型路由：
   - **Read** → 优先走 **Replica**
   - **Write** → 必须走 **Master**
3. ⭐ Master 接收写入并生成变更
4. ⭐ 变更 **复制**到各 Replica（同步/异步取决于实现）

------

**4) 三大收益（面试高分表达）**

- ⭐ **Performance（读性能/吞吐）**：读流量分摊到多个 Replica，查询并行化
- ⭐ **Reliability（可靠性/冗余）**：多副本保存数据，单机损坏可恢复
- ⭐ **Availability（可用性）**：某个副本挂了仍可读；更容易做故障切换（至少部分能力）

------

**5) Trade-offs（至少 3 个，必背）**

- ⭐ **一致性 vs 性能：Replication Lag**
  - ⚠️ Replica 可能 **落后** Master
  - ⚠️ “刚写入立刻读从库”可能读到旧数据（read-after-write 不保证）
- ⭐ **复杂度上升**
  - ⚠️ 需要：读写分离路由、健康检查、故障转移、数据修复/回放脚本
- ⭐ **Failover 正确性风险**
  - ⚠️ Master 挂了提升 Replica 为新 Master 时，Replica 可能没追上最新日志 → 可能丢最后一段写入
- ⭐ **写扩展有限（重要结论）**
  - ⚠️ 主从主要解决 **读扩展**；写仍集中在 Master → 写瓶颈仍可能存在

------

**6) 30 秒口述版（可直接背）**

- ⭐ “数据库复制通常是 1 个 Master 负责写，多个 Replica 负责读。Web 层写请求必须打到 Master，读请求优先走 Replica，Master 的变更再复制到 Replica。这带来读吞吐提升、数据冗余和更高可用。但代价是复制延迟导致一致性问题（刚写完读从库可能读不到）、系统复杂度更高（路由/健康检查/故障转移/修复脚本），并且写扩展仍受 Master 限制。”

## Cache

**1) 一句话结论（必背）**

- ⭐ **Cache = 内存里的临时数据层**：存**高频读/代价高**的结果，目标是 **降延迟 + 降 DB 压力**
- ⭐ **关键认知**：Cache **快但不可靠**（可能丢/可能旧），**不能替代 DB**

------

**2) 怎么考（常见问法）**

- ⭐ “为什么要 cache？解决什么问题？”
- ⭐ “读缓存流程是什么？hit/miss 怎么处理？”
- ⭐ “什么时候适合缓存？什么时候不适合？”
- ⭐ “TTL 是什么？怎么取舍？”
- ⚠️ “缓存会带来哪些坑？怎么答一致性/旧数据？”
- ⚠️ “缓存单点故障怎么避免？”
- ⭐ “缓存满了怎么办？淘汰策略有哪些？”（常考）

------

**3) 怎么答（评分点清单：按顺序说）**

**3.1 为什么需要 Cache（3点高分）**

- ⭐ **性能**：内存访问快 → **延迟显著下降**
- ⭐ **减压 DB**：减少重复查询 → DB 吞吐更稳、成本更低
- ⭐ **可扩展**：Cache 可独立扩容（加节点）

------

**4) 读路径标准套路（必背：Read-through / Cache-aside 读法）**

> 你笔记里的流程本质就是“先查 cache，miss 再查 DB，并回填 cache”

- ⭐ **流程（3步背诵版）**
  1. `get(key)` 查 cache
  2. **Hit**：直接返回
  3. **Miss**：查 DB → `set(key, value, ttl)` 回填 cache → 返回
- ⚠️ **易错**：面试一定要说出 **hit/miss + 回填（populate）**，否则显得不熟。

------

**5) 什么时候该用缓存（命中要点）**

- ⭐ **适合**
  - **读多写少**（read-heavy）
  - **热点明显**（首页、商品详情、用户资料、榜单等）
  - **结果计算代价高**（复杂查询/聚合/远程调用）
- ⚠️ **不适合/慎用**
  - **强一致且频繁变动**的数据（否则 stale 风险大）
  - **必须持久化**的数据（cache 重启会丢）

------

**6) Trade-offs（至少 3 个，必背）**

- ⭐ **性能 vs 一致性（staleness）**：缓存可能是旧数据
- ⭐ **TTL 长短取舍**：
  - ⚠️ TTL 短 → miss 多 → DB 压力回升
  - ⚠️ TTL 长 → stale 风险增大
- ⭐ **可靠性 vs 成本（SPOF）**：单 cache 节点是单点，做多副本/集群更可靠但更贵更复杂
- ⭐ **内存有限 → 淘汰策略影响命中率**：策略不合适会导致命中率低

------

**7) 常考概念：SPOF（单点故障）**

- ⭐ **定义**：只有一台关键缓存/服务，挂了就整体不可用
- ⭐ **应对**：多节点/集群/多副本（+ 健康检查/自动切换）
- ⚠️ 易错：只说“加机器”不够，记住要点出 **单点 → 冗余**。

------

**8) 缓存满了怎么办（Eviction 淘汰策略，必背）**

- ⭐ **LRU**：最近最少使用淘汰（面试最常用/最常说）
- ⭐ **LFU**：最不常用淘汰
- ⭐ **FIFO**：先进先出
- ⚠️ 易错：只背名词不够，至少能说一句“用于提高命中率/受访问模式影响”。

------

**9) 30 秒面试口述版（可直接背）**

- ⭐ “Cache 是内存里的临时数据层，用来缓存高频读或计算代价高的结果，降低延迟并减轻 DB 压力。读路径通常是先查 cache：hit 直接返回；miss 查询 DB 并回填 cache（带 TTL）。权衡点包括：缓存可能旧数据导致一致性问题、TTL 长短取舍、单点故障需要多节点冗余，以及内存有限需要 LRU/LFU/FIFO 等淘汰策略。”

## Content Delivery Network

**1) 一句话结论（必背）**

- ⭐ **CDN = 地理分布式的边缘缓存网络**：把 **静态资源**（image/video/CSS/JS）缓存到离用户最近的 **edge**，让用户就近获取 → **降延迟 + 降源站压力**。

------

**2) 怎么考（常见问法）**

- ⭐ “CDN 是什么？解决什么问题？”
- ⭐ “CDN 为什么更快？”（距离近、边缘节点）
- ⭐ “CDN 请求流程：hit/miss、回源（origin）怎么走？”
- ⭐ “CDN 和 cache 有什么区别？分别加速什么？”（高频对比题）
- ⚠️ “TTL 怎么取舍？内容更新怎么处理？”（stale / invalidation）
- ⚠️ “CDN 挂了怎么办？”（fallback/兜底）

------

**3) 怎么答（评分点清单：按顺序说）**

**3.1 核心收益（面试高分 3 点）**

- ⭐ **Latency 降低**：用户从最近 edge 拿资源（RTT 更小）
- ⭐ **减轻源站（origin）带宽/CPU**：静态分发外包给 CDN
- ⭐ **全球体验更稳**：跨地域访问性能更一致

**3.2 工作原理（必背：CDN hit/miss + 回源）**

- ⭐ **流程（5步背诵版）**
  1. 用户请求静态资源（通常是 CDN 域名）
  2. CDN edge 查缓存：**Hit** 直接返回
  3. **Miss**：CDN 回源到 **Origin**（Web server / S3 等）
  4. Origin 返回资源（带 TTL/Cache-Control 等）
  5. CDN 缓存资源并返回；后续请求在 TTL 内直接命中
- ⚠️ **易错**：面试一定要说清 **Origin 是谁**（Web server 或对象存储），以及 **回源（origin fetch）** 这个动作。

------

**4) 放到整体架构里怎么讲（必背对比句）**

- ⭐ **静态**：User → **CDN**（不再让 Web server 发静态文件）
- ⭐ **动态**：User → LB → Web → **Cache/DB**
- ⭐ 金句：**CDN 加速静态、Cache 加速动态（尤其是 DB 读）**
- ⚠️ 易混：CDN 本质也是缓存，但位置在“更靠近用户的边缘网络”，而应用 cache 通常在“服务端/数据层附近”。

------

**5) Trade-offs（至少 3 个，必背）**

- ⭐ **成本 vs 性能**：CDN 按流量/出网计费；冷门资源命中率低可能不划算
- ⭐ **TTL 取舍**：
  - ⚠️ TTL 长 → stale 风险高
  - ⚠️ TTL 短 → 回源频繁，收益变小、源站压力回升
- ⭐ **更新一致性（Invalidation/Versioning）**：
  - ⚠️ 静态内容更新后，CDN 可能继续发旧版本
  - 常用解法：**invalidation（失效）** 或 **资源版本化**（文件名带 hash/版本号）
- ⭐ **可用性/兜底**：CDN 也会故障 → 需要 fallback（例如回源直连/多 CDN 策略/合理超时重试）
  - ⚠️ 易错点：不提兜底，面试官会追问“CDN 挂了页面白屏怎么办”。

------

**6) 30 秒面试口述版（可直接背）**

- ⭐ “CDN 是一组分布式边缘服务器，用来缓存并分发静态资源，让用户从最近的 edge 获取，从而降低延迟并减少 origin 的带宽/CPU 压力。请求流程是：先查 edge 缓存，hit 直接返回；miss 回源到 origin（Web/S3），拿到后按 TTL 缓存并返回。它与 cache 的区别是：CDN 更偏静态内容且靠近用户；应用 cache 更偏动态数据/DB 读优化。权衡包括成本、TTL 导致的 stale、更新需要 invalidation/版本化，以及 CDN 故障的 fallback 机制。”

## Stateless Web Tier

**1) 一句话结论（必背）**

- ⭐ **Stateful**：Web server 本地保存 session/用户状态 → 请求必须回到同一台机器（常靠 sticky session）
- ⭐ **Stateless**：Web server 不保存客户端状态；状态放到 **共享存储**（Redis/DB/NoSQL）→ 任意请求可到任意机器，支持 **水平扩展 + Auto Scaling**

------

**2) 怎么考（常见问法）**

- ⭐ “stateful vs stateless 区别？为什么要 stateless？”
- ⭐ “sticky session 是什么？为什么不推荐长期用？”
- ⭐ “stateless 怎么做？session 放哪？”
- ⭐ “stateless 和 auto scaling 的关系？”
- ⚠️ “stateless 的代价/新瓶颈是什么？”（共享存储压力、HA）

------

**3) 怎么答（评分点清单：按顺序说）**

**3.1 Stateful 的问题（必须讲清）**

- ⭐ **必须 sticky session**：同一用户一直路由到同一台服务器，否则 session 缺失 → 认证失败
- ⭐ **代价（背 4 点）**
  1. ⚠️ **扩缩容困难**：加/减机器会破坏粘性映射，迁移麻烦
  2. ⚠️ **故障影响大**：机器挂了 session 也没了 → 用户掉线/重登
  3. ⚠️ **负载不均**：热点用户粘在某台 → 可能打爆
  4. ⚠️ **运维复杂**：粘性策略、迁移、容灾更难
- ⭐ 结论金句：**sticky session 可救急，但不适合长期大规模。**

**3.2 Stateless 的做法（必背：state externalization）**

- ⭐ **核心动作**：把 session/状态从 Web server 内存移到 **Shared Storage**
- ⭐ **请求流程（3步背诵版）**
  1. 请求到任意 Web server
  2. 需要状态时从共享存储读取/更新
  3. 返回响应（LB 可自由分发）
- ⭐ **共享存储常见选项**
  - ⭐ Redis/Memcached（常用 session，快）
  - SQL/NoSQL（可持久/可扩展，按场景选）

**3.3 为什么 Stateless 才能 Auto Scaling（必背）**

- ⭐ Web server 不带状态 → **新增/下线实例不影响用户会话**
- ⭐ LB 可把请求随意分发 → **弹性伸缩自然成立**

------

**4) Trade-offs（至少 3 个，必背）**

- ⭐ **Web 易扩展 vs 共享存储可能成瓶颈**
  - ⚠️ 所有请求都要读写 session → Redis/存储需集群/分片/副本
- ⭐ **可用性要求更高**
  - ⚠️ session 在关键路径，共享存储必须 HA（多副本/多 AZ）
- ⭐ **工程复杂度**
  - ⚠️ 需要设计：cookie/token、过期 TTL、登出/刷新、并发更新
- ⭐（对比点）**sticky 简单 vs 长期风险高**（容灾/扩容/热点）

------

**5) 30 秒面试口述版（可直接背）**

- ⭐ “Stateful web server 把 session 存在本机，导致请求必须回到同一台机器，通常要 sticky session，但这会带来扩缩容困难、故障会话丢失、负载不均和运维复杂。Stateless 的做法是把状态外置到共享存储（常用 Redis），web server 本身无状态，因此 LB 可以自由分发请求，实例可以随时增减，从而支持水平扩展和 auto scaling。代价是共享存储成为关键路径，需要高可用并避免瓶颈，同时增加 session/token/TTL 等工程复杂度。”

## Data Center

**0) 一句话总纲（必背）**

- ⭐ **多 Region/多数据中心**：同一套服务部署在多个地理位置 → **抗机房级故障 + 降跨洲延迟**；代价是 **数据同步与运维复杂度**。

------

**1) Multi-Data Center / Multi-Region（怎么考怎么答）**

**怎么考**

- ⭐ “为什么需要多 Region？解决什么问题？”
- ⭐ “多 Region 和多 AZ 区别？”（常考混淆）
- ⚠️ “多 Region 就一定高可用吗？”（追问陷阱）

**怎么答（3点评分点）**

- ⭐ **目的 1：容灾**（机房/Region 级故障仍可服务）
- ⭐ **目的 2：低延迟**（用户就近访问）
- ⚠️ **前提**：必须配套 **流量切换 + 数据复制 + 状态管理 + 演练**，否则“有多机房也会翻车”
- ❌ 不记：生活类比长段，只背“远（慢）+ 挂（死）”。

------

**2) GeoDNS（地理 DNS）＝“入口选哪家”**

**怎么考**

- ⭐ “GeoDNS 是什么？跟 LB 区别？”
- ⚠️ “GeoDNS 故障切流能多快？”（TTL 缓存）

**怎么答（必背）**

- ⭐ **定义**：DNS 按用户地理位置/策略，把域名解析到最近（或指定）的 Region 入口
- ⭐ **作用**：**就近入口选择**（降低延迟）
- ⚠️ **关键限制**：DNS 有缓存（TTL）→ **切流不一定秒级**
- ⚠️ **必须配合**：健康检查/更上层流量管理，否则可能解析到“坏机房”

------

**3) Failover（故障切换）＝“挂了怎么切、怎么保护”**

**怎么考**

- ⭐ “Region 挂了怎么 failover？”
- ⚠️ “为什么切流本身也可能把另一个机房压垮？”（重试风暴/容量）

**怎么答（高分点）**

- ⭐ **定义**：检测某 Region 不健康，将流量切到健康 Region（例如 50/50 → 100/0）
- ⭐ **关键不是切，而是：**
  1. ⭐ **健康检测**（别把流量继续送死）
  2. ⚠️ **渐进式切流**（避免瞬间把健康 Region 冲垮）
  3. ⚠️ **限流/熔断/控制重试**（防“重试风暴”雪崩放大）
- ⚠️ 追问准备：切过去后 **容量是否够**、依赖是否跨 Region 可用

------

**4) Data Synchronization（跨 Region 数据同步）**

**怎么考**

- ⭐ “多 Region 数据怎么保证一致？”
- ⚠️ “同步 vs 异步复制区别？什么时候选哪种？”
- ⚠️ “Active-Active 写冲突怎么办？”（常追问）

**怎么答（必背框架）**

- ⭐ **定义**：多 Region 各自有数据时，保证复制/同步，让 failover 后不出现“数据消失/回滚感”
- ⭐ **核心权衡**：**延迟 vs 一致性**
  - ⭐ 金融/支付更偏强一致（成本高、延迟高）
  - ⭐ 内容/社交更偏最终一致（延迟低）
- ⚠️ **常见坑**
  - 复制≠实时强一致（跨洲网络决定成本）
  - **写冲突**（Active-Active 同时写同一数据）
  - 只复制 DB 不考虑缓存：切流后缓存全 miss，后端被打穿

------

**5) Test & Deployment（多 Region 运维发布）**

**怎么考**

- ⭐ “多 Region 怎么发布？怎么保证一致？”
- ⚠️ “为什么灾备一定要演练？”

**怎么答（评分点）**

- ⭐ **必须具备**：自动化 **CI/CD + 配置管理 + 可回滚**
- ⚠️ **风险**：两地版本/Schema/配置不一致 → 一切流就崩
- ⭐ **演练**：灾备不演练 = 真出事必翻车

------

**6) 必会对比题（高频）**

**GeoDNS vs Load Balancer**

- ⭐ **GeoDNS**：决定“去哪个 Region/机房”（入口层）
- ⭐ **LB**：决定“机房内去哪台/哪个服务”（机房内分发）
- ⚠️ 易错：把 GeoDNS 当 LB（或反过来）

**Active-Active vs Active-Passive**

- ⭐ **Active-Active**：平时两地都接流量（利用率高、低延迟）
  - ⚠️ 难点：数据一致性/写冲突更复杂
- ⭐ **Active-Passive**：平时只有主站接流量，备站待命
  - ⚠️ 缺点：资源浪费、切换可能更慢（但实现更简单）

**Synchronous vs Asynchronous Replication**

- ⭐ **Sync**：写入需两边确认 → 一致性更强、延迟更高
- ⭐ **Async**：本地先成功再复制 → 延迟更低、可能丢“最后一段写”
- ⚠️ 易错：把 async 说成“不会丢数据”（故障窗口内可能丢）

------

**7) 30 秒口述版（可直接背）**

- ⭐ “多 Region 的核心价值是抗机房级故障和降低跨洲延迟。入口通常用 GeoDNS 让用户就近解析到 Region，但 DNS 有 TTL 缓存，切流不一定秒级，需要健康检查与流量管理。Region 故障时做 failover，关键是健康检测、渐进式切流以及限流/熔断防重试风暴。最大的难点是跨 Region 数据同步：在一致性与延迟间权衡，Active-Active 会带来写冲突，另外还要保证多地版本/配置一致并持续演练灾备。”

## Message Queue

**1) 一句话结论（必背）**

- ⭐ **MQ = 可靠中转站**：Producer 先把任务/事件放队列里，Consumer 按自己的节奏取走处理 → **异步解耦 + 削峰填谷 + 故障隔离 + 独立扩缩容**。

------

**2) 怎么考（高频问法）**

- ⭐ “为什么要 MQ？不用会怎样？”
- ⭐ “MQ 解决了哪些问题？核心价值是什么？”
- ⭐ “基本流程：publish/consume/ack/retry/DLQ？”
- ⚠️ “MQ 是不是让系统更快？”（陷阱）
- ⚠️ “如何保证不丢/不重复？幂等怎么做？”（最常追问）
- ⭐ “Queue vs Pub/Sub 区别？”
- ⭐ “MQ vs Cache 区别？”

------

**3) 怎么答（评分点清单：按顺序说）**

**3.1 为什么需要 MQ（没有它的灾难点）**

- ⭐ **慢任务拖死请求**：同步链路被下游耗时卡住 → 超时/体验差
- ⭐ **下游挂了上游也挂**：直连导致级联失败
- ⭐ **流量尖峰打爆下游**：瞬时高峰无法消化 → 崩溃
- ⭐ **无法独立扩缩容**：处理能力不能单独水平扩展

**3.2 核心价值（面试金句版）**

- ⭐ “用 MQ 把同步链路变成**异步解耦**：**削峰填谷、隔离故障、让生产者/消费者独立扩缩容**，并通过 **重试 + 幂等 + DLQ** 保证可靠性。”

------

![image-20260125014111067](C:\Learning Notes\Java\系统设计之神\img\image-20260125014111067.png)

**4) 标准工作流（必背：5步）**

1. ⭐ Producer **publish** 消息到 Queue（不等处理完成）
2. ⭐ Queue 作为 **buffer/持久化** 中转（可能分区/顺序）
3. ⭐ Consumer **consume**（拉取/接收）并处理
4. ⭐ 处理成功 **ack**（确认）；失败则 **retry**
5. ⭐ 多次失败进入 **DLQ（死信队列）**，隔离并人工/脚本处理

口诀（背这个就够）：

- ⭐ **publish → buffer → consume → ack → DLQ**

------

**5) 最容易考的坑（必须会答）**

- ⚠️ **MQ ≠ 让任务更快完成**
  - MQ 让“用户响应更快”（先返回已接收），但任务可能排队更久
- ⚠️ **至少一次投递（at-least-once）→ 可能重复**
  - ⭐ 必须做 **幂等/去重**（幂等 key、去重表、业务唯一约束）
- ⚠️ **重试策略 + DLQ 必须有**
  - 否则失败消息无限重试会堵队列/拖垮系统
- ⚠️ **必须监控积压（lag/backlog）**
  - 队列长度上升 = 消费跟不上 = 系统慢性死亡
- ❌ **别把 MQ 当数据库**
  - MQ 不是长期历史存储（保留期、查询能力都不适合）

------

**6) 高频对比题（直接背）**

**同步 vs 异步（MQ）**

- ⭐ **同步**：现在就要结果；下游慢=上游慢
- ⭐ **异步（MQ）**：先交任务；结果稍后通过回调/轮询/通知
- ⭐ 金句：**同步追求即时体验；异步追求吞吐与韧性，慢任务优先异步化。**

**Queue vs Pub/Sub**

- ⭐ **Queue**：一条消息通常由 **一个消费者组**处理（任务分发）
- ⭐ **Pub/Sub**：一条消息被 **多个订阅者**各自收到（事件广播）

**MQ vs Cache**

- ⭐ **MQ**：传“要处理的任务/事件”
- ⭐ **Cache**：存“加速读取的数据副本”

------

**7) 30 秒面试口述版（可直接背）**

- ⭐ “消息队列是可靠中转站，用于把同步调用改成异步解耦：生产者发布消息后立即返回，队列负责缓冲削峰，消费者按能力拉取处理并 ack。这样可以隔离下游故障、避免尖峰打爆、并让消费者水平扩展。关键工程点是可靠性：常见至少一次投递会导致重复，所以必须幂等；失败要有重试策略和 DLQ；同时监控队列积压，避免系统慢性堆积。”

## Logging, Metrics, Automation

**0) 一句话总纲（必背）**

- ⭐ **Observability 三件套**：
  - ⭐ **Logs**：发生了什么（证据）
  - ⭐ **Metrics**：坏到什么程度/趋势（体征）
  - ⭐ **Tracing**：坏在链路哪一跳（定位）
- ⭐ **Monitoring/Alerting**：让问题“自动叫醒人”
- ⭐ **Automation**：让修复/发布“快、稳、可复现、可回滚”

口诀（背这个就够）：

- ⭐ **Logs 证据 — Metrics 体征 — Alerts 叫醒 — Trace 定位 — Automation 自动救**

------

**1) Logging（日志）**

**一句话定义**

- ⭐ **Logging**：把系统事件记录下来用于排障与审计。

**怎么考**

- ⭐ “日志怎么设计才能排查跨服务问题？”
- ⚠️ “日志有哪些常见坑？安全怎么做？”

**怎么答（得分点）**

- ⭐ **Structured logs（结构化）**：JSON/字段化，便于检索聚合
- ⭐ **Correlation ID**：`request_id/trace_id` 全链路贯穿
- ⭐ **Centralized logging**：集中采集（不落单机）
- ⚠️ 易错：
  - 只打散装字符串（难查询）
  - 没 request_id（串不起来）
  - 泄露 PII/token
  - 日志量失控（噪音/成本）

------

**2) Metrics（指标）**

**一句话定义**

- ⭐ **Metrics**：用数字持续衡量系统状态（随时间变化）。

**怎么考**

- ⭐ “你会监控哪些核心指标？”
- ⚠️ “为什么不能只看平均值？”

**怎么答（必背：四个黄金信号）**

- ⭐ **Golden Signals（L T E S）**
  - ⭐ Latency（P95/P99）
  - ⭐ Traffic（QPS/RPS）
  - ⭐ Errors（error rate）
  - ⭐ Saturation（资源饱和：CPU/内存/队列积压等）
- ⚠️ 易错：
  - 只看平均值不看 P95/P99
  - label/cardinality 爆炸
  - 只做技术指标不做业务指标（DAU/转化等）

------

**3) Monitoring & Alerting（监控与告警）**

**一句话定义**

- ⭐ Monitoring = 看趋势/仪表盘；⭐ Alerting = 超阈值/异常就通知 oncall。

**怎么考**

- ⭐ “告警怎么设才不吵、不漏？”
- ⚠️ “CPU 90% 告警是不是好告警？”（陷阱）

**怎么答（得分点）**

- ⭐ **用 SLI/SLO 定义‘什么叫坏’**：围绕用户体验/业务损失触发
- ⭐ **去抖/持续时间**：例如连续 5 分钟才触发，减少抖动
- ⭐ **分级**：P0/P1/P2，避免“全是狼来了”
- ⚠️ 易错：
  - 有 dashboard 没告警（看得见≠会叫）
  - 只盯 CPU（可能不影响用户）
  - 告警噪音导致 alert fatigue

------

**4) Distributed Tracing（分布式追踪）**

**一句话定义**

- ⭐ **Tracing**：一次请求的全链路耗时分解（每一跳花多久、卡在哪）。

**怎么考**

- ⭐ “logs/metrics/tracing 有何区别？什么时候用 tracing？”
- ⚠️ “trace 怎么串起来？成本怎么控？”

**怎么答（必背点）**

- ⭐ **trace_id 贯穿 + context propagation**（跨服务传递上下文）
- ⭐ **sampling**：全量太贵，需要采样策略
- ⭐ 经典金句：**Logs 告诉我发生了什么；Metrics 告诉我坏到什么程度；Tracing 告诉我坏在哪一跳。**
- ⚠️ 易错：只在入口打点、下游不传递 trace_id；无采样导致成本爆炸

------

**5) Automation（自动化：CI/CD + 运维）**

**一句话定义**

- ⭐ **Automation**：让构建/测试/发布/扩缩容/回滚/修复自动化，降低人为风险。

**怎么考**

- ⭐ “为什么需要 CI/CD？怎么保证可回滚？”
- ⚠️ “自动扩容有什么风险？”（成本/上限）

**怎么答（得分点）**

- ⭐ **CI**：每次提交可验证（自动测试/静态检查）
- ⭐ **CD**：可控发布（灰度/金丝雀）+ **快速回滚**
- ⭐ **IaC**：基础设施代码化，环境一致，减少配置漂移
- ⚠️ 易错：
  - 只自动化部署，不自动化回滚/演练
  - auto-scaling 无上限 → 成本失控
  - 配置漂移导致“只在某台机器出 bug”

------

**6) 30 秒口述版（可直接背）**

- ⭐ “线上稳定性我会用 observability 三件套：结构化日志并带 request_id/trace_id 做全链路串联；指标优先看四个黄金信号 LTES，尤其是 P95/P99 延迟；告警围绕 SLI/SLO 设计，带去抖和分级避免噪音；Tracing 用来定位具体卡在哪个服务/哪一跳，同时做采样控制成本。最后用 CI/CD + IaC 实现可控发布、快速回滚和自动化运维，降低人为错误并缩短 MTTR。”

## Database Scaling

**0) 五连击总纲（必背）**

- ⭐ 路线：**先 Scale Up → 再 Sharding → 选 Shard Key → 能 Reshard → 处理 Hotspot**
- ⭐ 口诀：**“先加大，再加多；键选对，能搬家；防热点，别炸锅。”**

------

**1) Vertical Scaling（Scale Up）**

**一句话定义**

- ⭐ 给同一台 DB 加资源（CPU/RAM/Disk）。

**怎么考**

- ⭐ “DB 扩容先做什么？为什么先 scale up？”
- ⚠️ “scale up 有什么硬缺点？”

**怎么答（得分点）**

- ⭐ **优点**：改动最小、最快落地、风险低（早期首选）
- ⚠️ **缺点（背 4 点）**
  1. **硬件上限**（不可无限）
  2. **SPOF**（单点风险）
  3. **成本曲线陡**（越大性价比越差）
  4. **写瓶颈仍可能存在**（锁/IO/日志写入）
- ❌ 不记：类比长段，只记“快但到顶+单点”。

------

**2) Horizontal Scaling / Sharding（分片）**

**一句话定义**

- ⭐ **Sharding**：把一张大库/大表拆到多个 shard，每个 shard 存一部分数据。

**怎么考**

- ⭐ “什么时候必须 sharding？”
- ⭐ “分片后带来哪些新复杂度？”

**怎么答（得分点）**

- ⭐ **目的**：把单点瓶颈变并行 → **容量/吞吐可线性扩展**
- ⚠️ **分片不是自动快**：跨 shard 查询/事务更难
- ⚠️ 必要组件：**路由层**（根据 key 找 shard）

------

**3) Sharding Key / Partition Key（分片键）**

<img src="C:\Learning Notes\Java\系统设计之神\img\image-20260125022504534.png" alt="image-20260125022504534" style="zoom:25%;" />

**一句话定义**

- ⭐ 决定一条数据落在哪个 shard 的字段（或组合）。

**怎么考（高频追问）**

- ⭐ “分片键怎么选？什么是好 key？”
- ⚠️ “为什么 timestamp/region 可能是坏 key？”

**怎么答（必背：三连问）**

- ⭐ 选 key 看三点：
  1. ⭐ **好路由**：查询能用它直接定位 shard（避免全扫）
  2. ⭐ **够均匀**：数据 & 流量分布均匀（避免倾斜）
  3. ⭐ **少跨片**：减少跨 shard join/事务
- ⚠️ 易错点
  - 只看数据均匀，不看访问均匀（热点来自访问模式）
  - 用时间戳做 key → 新写集中到某 shard（写热点）
  - key 选错导致频繁跨片事务/Join（代价大）

------

**4) Resharding（再分片）+ Consistent Hashing（一致性哈希）**

**一句话定义**

- ⭐ **Resharding**：增加/调整 shard 时迁移数据并更新路由
- ⭐ **Consistent Hashing**：加/减节点时尽量只迁移“局部数据”，减少搬家量

**怎么考**

- ⭐ “为什么 reshard 很痛？mod N 有什么问题？”
- ⭐ “一致性哈希怎么分配 key？规则是什么？”（必考）
- ⚠️ “迁移怎么做到不停机？”（工程追问）

**怎么答（必背要点）**

- ⭐ **mod N 痛点**：`hash(key)%N` 从 N→N+1 会导致**大量 key 映射变化** → 90%+ 数据搬迁、cache 失效
- ⭐ **一致性哈希规则（必背一句）**：
  - 把 **节点** 和 **key** 都 hash 到同一 ring
  - ⭐ **key 放到顺时针遇到的第一个节点**
- ⭐ 面试金句：难点不是算法，是 **在线迁移**：
  - ⚠️ **双写/回填/校验/切读/回滚**
- ⚠️ 易错：只会说“改个 hash 就行”——必须提“在线迁移+回滚”。

------

**5) Hotspot Key / Celebrity Problem（热点）**

**一句话定义**

- ⭐ 某些 key/某个 shard 被访问特别多 → 局部过载，可能引发雪崩。

**怎么考**

- ⭐ “分片后为什么还会热点？”
- ⭐ “热点怎么解决？”（必考）

**怎么答（得分点）**

- ⭐ **热点原因**：访问模式不均匀（明星/爆款/热门房间）
- ⭐ **常见解法（背 4 个）**
  1. ⭐ **缓存**（热点读优先 cache/CDN）
  2. ⭐ **复制/多副本**（热点数据多份分摊读）
  3. ⭐ **专用分片/拆分热点**（把热点 key 拆到独立 shard 或更细粒度）
  4. ⭐ **改写路径**（预计算/fanout/异步化，避免实时集中打一个点）
- ⚠️ 易错：只“加机器”没用——热点 key 仍落同一个 shard。

------

**6) 高频对比题（必背）**

**Vertical vs Sharding**

- ⭐ Vertical：快、改动小；⚠️ 有上限+单点
- ⭐ Sharding：容量/吞吐可扩；⚠️ 路由/迁移/跨片查询复杂

**Sharding vs Replication**

- ⭐ **Sharding**：分数据（不同 shard 存**不同数据**）→ 解决**容量/吞吐**
- ⭐ **Replication**：复制数据（多副本存**相同数据**）→ 解决**可用性/读扩展**

------

**7) 30 秒面试口述版（可直接背）**

- ⭐ “数据库扩展一般先 scale up，因为改动最小，但它有硬件上限且是单点。规模继续涨就要 sharding，把数据拆到多个 shard 并通过路由层按 sharding key 定位。分片键要满足：能路由、分布均匀、尽量少跨片。增长后需要 resharding，mod N 会导致大迁移，所以常用一致性哈希减少重映射；工程上关键是在线迁移（双写/回填/校验/切读/回滚）。另外分片不能自动解决热点，热点要用缓存/复制/专用分片或改写路径处理。”

















